# Listenarr Copilot Rules

## Project Overview
Listenarr is a C# .NET Core Web API backend with Vue.js frontend for automated audiobook downloading and processing. The backend uses ASP.NET Core with Entity Framework Core and SQLite, while the frontend uses Vue.js 3 with TypeScript, Pinia, and Vite.

## Coding Standards & Patterns

### Backend (C#)

#### Architecture
- **Service Layer Pattern**: All business logic goes in Services (e.g., `SearchService`, `DownloadService`)
- **Repository Pattern**: Database operations through repositories (e.g., `AudiobookRepository`)
- **Dependency Injection**: All services use constructor injection
- **Async/Await**: All I/O operations must be async

#### Naming Conventions
- **Classes**: PascalCase (e.g., `AudiobookRepository`, `SearchService`)
- **Methods**: PascalCase (e.g., `GetByIdAsync()`, `ProcessDownloadAsync()`)
- **Properties**: PascalCase (e.g., `Title`, `CreatedAt`)
- **Private Fields**: camelCase with underscore prefix (e.g., `_logger`, `_dbContext`)
- **Interfaces**: Start with 'I' (e.g., `IAudiobookRepository`, `ISearchService`)

#### Code Structure
```csharp
// Service class example
public class ExampleService : IExampleService
{
    private readonly ILogger<ExampleService> _logger;
    private readonly IRepository _repository;

    public ExampleService(ILogger<ExampleService> logger, IRepository repository)
    {
        _logger = logger;
        _repository = repository;
    }

    public async Task<Result> DoSomethingAsync(Request request)
    {
        try
        {
            // Validation
            if (request == null) throw new ArgumentNullException(nameof(request));

            // Business logic
            var result = await _repository.GetSomethingAsync(request.Id);

            // Logging
            _logger.LogInformation("Did something for {Id}", request.Id);

            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to do something for {Id}", request.Id);
            throw;
        }
    }
}
```

#### Error Handling
- Use try/catch blocks for all public methods
- Log errors with appropriate log levels
- Re-throw exceptions after logging (don't swallow them)
- Use custom exceptions for business logic errors

#### Logging
- Use structured logging with placeholders: `_logger.LogInformation("Processing {Item} for {User}", item, user)`
- Log levels: Debug (detailed), Information (normal operations), Warning (unexpected but handled), Error (failures)
- Include relevant context in log messages

#### Database
- Use Entity Framework Core with async methods
- Include related entities when needed: `.Include(a => a.Files)`
- Use navigation properties for relationships
- Apply migrations automatically on startup

### Frontend (Vue.js + TypeScript)

#### Component Structure
```vue
<template>
  <div class="component">
    <!-- Template content -->
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'
import { useStore } from '@/stores/store'

// Props
interface Props {
  item?: Item
  loading?: boolean
}
const props = withDefaults(defineProps<Props>(), {
  loading: false
})

// Emits
const emit = defineEmits<{
  selected: [item: Item]
  closed: []
}>()

// Reactive data
const items = ref<Item[]>([])
const loading = ref(false)

// Computed
const hasItems = computed(() => items.value.length > 0)

// Methods
const handleSelect = (item: Item) => {
  emit('selected', item)
}

const loadData = async () => {
  try {
    loading.value = true
    items.value = await apiService.getItems()
  } catch (error) {
    console.error('Failed to load items:', error)
  } finally {
    loading.value = false
  }
}

onMounted(() => {
  loadData()
})
</script>

<style scoped>
.component {
  /* Styles */
}
</style>
```

#### State Management (Pinia)
- Use Pinia stores for global state
- Actions should be async and handle errors
- Use getters for computed state
- Follow the pattern: `useStoreNameStore`

#### API Communication
- Use a centralized API service
- Handle errors consistently
- Use TypeScript interfaces for request/response types
- Implement proper error handling and user feedback

#### Naming Conventions
- **Components**: PascalCase (e.g., `AudiobookCard.vue`, `SearchForm.vue`)
- **Files**: kebab-case (e.g., `audiobook-card.vue`, `search-form.vue`)
- **Variables**: camelCase (e.g., `selectedItem`, `isLoading`)
- **Types**: PascalCase (e.g., `Audiobook`, `SearchResult`)

### General Rules

#### File Organization
- **Backend**: Follow the established folder structure (Controllers/, Services/, Models/, etc.)
- **Frontend**: Use the established folder structure (components/, views/, stores/, etc.)
- Keep related files together
- Use index files for clean imports

#### Testing
- Write unit tests for business logic
- Mock external dependencies
- Use descriptive test names
- Test both success and error scenarios

#### Documentation
- Add XML comments to public methods and classes
- Keep README files up to date
- Document complex business logic
- Use clear commit messages

#### Performance
- Use async/await for I/O operations
- Implement caching where appropriate
- Avoid N+1 queries in database operations
- Use lazy loading for heavy components

#### Security
- Validate all input data
- Use parameterized queries
- Implement proper authentication/authorization
- Sanitize user inputs
- Follow OWASP guidelines

### Critical Backend Patterns

#### Download Status Lifecycle (CompletedDownloadProcessor.cs)
- **ALWAYS set `Status = DownloadStatus.Moved`** after successful file processing (8 locations)
- Create history entries and notifications **BEFORE** cleanup operations
- For Transmission: Extract torrent hash using `torrentInfo.HashString` (not `download.ExternalId`)
- Status flow: Queued → Downloading → Completed → Moved (terminal state)

#### File Existence Validation (Library/Wanted Status)
- **Check physical disk files**, not just database records
- Pattern: `a.Monitored && (a.Files == null || !a.Files.Any() || !a.Files.Any(f => !string.IsNullOrEmpty(f.Path) && System.IO.File.Exists(f.Path)))`
- Apply in: LibraryController.GetAllAudiobooks, LibraryController.GetAudiobook, ScanBackgroundService.BroadcastLibraryUpdate
- Prevents false positives where DB records exist but files were deleted

#### Download Client Authentication
- **Transmission**: 409/session-id retry pattern for CSRF (PollTransmissionAsync, TransmissionAdapter)
- **qBittorrent**: Cookie-based session authentication
- **SABnzbd/NZBGet**: API key authentication

#### Background Services & Job Processing
- `DownloadProcessingBackgroundService`: Implements `ResetStuckJobsAsync()` on startup
- Jobs can get stuck in "Processing" state if service crashes
- Reset stuck jobs automatically on startup to prevent queue blockage
- Use 30-second stability window in `DownloadMonitorService` to prevent premature imports

### Critical Frontend Patterns

#### Pinia Store Best Practices
- **downloads.ts**: Filter terminal states from active downloads
  - `activeDownloadsByAudiobook`: Exclude 'Completed', 'Moved', 'Failed', 'Cancelled' statuses
  - Use `queueItem.title` for title, NOT `contentPath` (doesn't exist)
- **library.ts**: SignalR real-time updates with reconnection logic
- Use computed properties for derived state, never mutate store state directly

#### Visual Feedback & Performance
- Use `v-memo` for large lists (e.g., WantedView audiobook cards)
- Include all reactive dependencies: `v-memo="[audiobook, activeDownloads[audiobook.id]]"`
- Show download indicators with pulse/bounce animations (CSS keyframes)
- Filter downloads by audiobook using `activeDownloadsByAudiobook` computed property

#### Type Safety
- All API responses must have TypeScript types in `types/index.ts`
- Download status: 'Queued' | 'Downloading' | 'Completed' | 'Paused' | 'Failed' | 'Cancelled' | 'Moved'
- Never reference non-existent properties (causes TS2339 errors)

### Common Troubleshooting

#### Downloads Not Importing
1. Check logs: `listenarr.api/config/logs/listenarr-YYYYMMDD.log`
2. Look for authentication errors (401, 409, Unauthorized)
3. Verify DownloadMonitorService is detecting candidates
4. Check stability window logs (30-second delay)
5. Ensure files exist on disk and are accessible

#### Multiple Database Files
- Running from `bin/Debug` creates a second, empty database
- **Always run from repository root** (`npm run dev`)
- Canonical DB: `listenarr.api/config/database/listenarr.db`

#### Hot Reload Not Working
- Backend: Restart `dotnet run` if changes aren't reflected
- Frontend: Restart `npm run dev` if Vite HMR fails
- File locks may prevent hot reload; full restart resolves this

### Development Workflow

1. **Branching**: Use feature branches for new work
2. **Commits**: Make small, focused commits with clear messages
3. **Testing**: Run tests before committing
4. **Code Review**: Submit PRs for review
5. **Deployment**: Use automated deployment scripts

### Common Patterns

#### API Response Format
```csharp
// Success response
return Ok(new { data = result, message = "Success" });

// Error response
return BadRequest(new { error = "Invalid request", details = validationErrors });

// Not found
return NotFound(new { error = "Item not found" });
```

#### Frontend Error Handling
```typescript
try {
  const result = await apiService.doSomething(request)
  // Handle success
} catch (error) {
  if (error.response?.status === 400) {
    // Handle validation errors
  } else if (error.response?.status === 404) {
    // Handle not found
  } else {
    // Handle other errors
  }
}
```

#### Database Queries
```csharp
// Good: Use async and include related data
var audiobooks = await _db.Audiobooks
    .Include(a => a.Files)
    .Where(a => a.Monitored)
    .OrderBy(a => a.Title)
    .ToListAsync();

// Avoid: Synchronous database calls
// Avoid: N+1 queries without Include
```

Remember: This project follows established patterns. When in doubt, look at existing code for examples of how similar functionality is implemented.</content>
<parameter name="filePath">c:\Users\Robbie\Documents\GitHub\Listenarr\.cursorrules