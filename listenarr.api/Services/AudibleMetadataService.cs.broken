using System.Net.Http;
using System.Threading.Tasks;
using ListenArr.Api.Models;
using HtmlAgilityPack;
using System.Text.Json;
using System.Linq;
using System.Collections.Generic;
using Microsoft.Playwright;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;

namespace ListenArr.Api.Services
{
    public class AudibleMetadataService : IAudibleMetadataService
    {
        // Playwright fallback counter
        private static long _playwrightFallbackCount = 0;

        private readonly HttpClient _httpClient;
        private readonly ILogger<AudibleMetadataService> _logger;
        private readonly IMemoryCache? _cache;
                    // Extract publisher from description - look for (P)YYYY Publisher pattern
                    if (string.IsNullOrWhiteSpace(metadata.Publisher))
                    {
                        var publisherMatch = System.Text.RegularExpressions.Regex.Match(metadata.Description, @"\(P\)\d{4}\s+([^\u00a9\n]+)", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                        if (publisherMatch.Success)
                        {
                            metadata.Publisher = publisherMatch.Groups[1].Value.Trim();
                            _logger.LogInformation("Extracted publisher from description: {Publisher}", metadata.Publisher);
                        }
                    }
                }
                else
                {
                    _logger.LogWarning("Summary text too short or looks like UI element: {Text}", summary?.Substring(0, Math.Min(50, summary?.Length ?? 0)));
                }
            }

            // Narrators - Extract from FULL PAGE after Playwright rendering
            // Try multiple patterns: /narrator/ links, /pd/ links with narrator names, or text patterns
            var pageNarratorNodes = doc.DocumentNode.SelectNodes("//a[contains(@href,'/narrator/')] | //span[contains(@class,'narratorLabel')]/following-sibling::span//a | //li[contains(text(),'Narrated by')]//a");
            if (pageNarratorNodes != null)
            {
                var narrators = pageNarratorNodes
                    .Select(n => n.InnerText?.Trim())
                    .Where(s => !string.IsNullOrWhiteSpace(s) && !s.Contains("Narrated by", StringComparison.OrdinalIgnoreCase))
                    .Distinct()
                    .Take(5) // Limit to first 5 narrators from product details area
                    .ToList();
                if (narrators.Any())
                {
                    metadata.Narrators = narrators!;
                    _logger.LogInformation("Extracted {Count} narrator(s) from Playwright-rendered page: {Narrators}", narrators.Count, string.Join(", ", narrators));
                }
                else
                {
                    _logger.LogWarning("Found {Count} narrator links but all filtered out", pageNarratorNodes.Count);
                }
            }
            
            // If no narrator links found, try parsing from description text as last resort
            if (metadata.Narrators == null || !metadata.Narrators.Any())
            {
                var descText = metadata.Description ?? "";
                _logger.LogInformation("Attempting to parse narrators from description (length: {Length})", descText.Length);
                // Look for "Now with two bonus chapters read by Teddy Hamilton" pattern
                var readByMatch = System.Text.RegularExpressions.Regex.Match(descText, @"read by ([^.]+)", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                if (readByMatch.Success)
                {
                    var narratorName = readByMatch.Groups[1].Value.Trim();
                    metadata.Narrators = new List<string> { narratorName };
                    _logger.LogInformation("Extracted narrator from description text: {Narrator}", narratorName);
                }
                else
                {
                    _logger.LogWarning("No narrator links found and could not parse from description text");
                }
            }readonly ILoggerFactory _loggerFactory;

        public AudibleMetadataService(HttpClient httpClient, ILogger<AudibleMetadataService> logger, IMemoryCache? cache = null, ILoggerFactory? loggerFactory = null)
        {
            _httpClient = httpClient;
            _logger = logger;
            _cache = cache;
            _loggerFactory = loggerFactory ?? LoggerFactory.Create(_ => { });
        }

        public async Task<AudibleBookMetadata> ScrapeAudibleMetadataAsync(string asin)
        {
            if (string.IsNullOrWhiteSpace(asin)) return new AudibleBookMetadata();

            var cacheKey = $"audible:metadata:{asin}";
            if (_cache != null && _cache.TryGetValue(cacheKey, out AudibleBookMetadata? cached) && cached != null)
            {
                _logger.LogDebug("Cache hit for ASIN {Asin}", asin);
                return cached;
            }

            // Try Audible product page first, then Amazon fallback on 404
            var tryUrls = new[] {
                $"https://www.audible.com/pd/{asin}",
                $"https://www.amazon.com/dp/{asin}",
                $"https://www.amazon.com/gp/product/{asin}"
            };

            foreach (var url in tryUrls)
            {
                try
                {
                    var (html, statusCode) = await GetHtmlAsync(url);
                    
                    // If Audible returns 404, immediately try Amazon
                    if (statusCode == 404 && url.Contains("audible.com"))
                    {
                        _logger.LogDebug("Audible returned 404 for ASIN {Asin}, trying Amazon fallback", asin);
                        continue;
                    }
                    
                    if (string.IsNullOrEmpty(html)) continue;
                    
                    var doc = new HtmlDocument();
                    doc.LoadHtml(html);

                    var metadata = new AudibleBookMetadata();

                    // Attempt to pull structured JSON-LD first (if present) â€” often contains reliable data
                    var jsonLd = ExtractFromJsonLd(doc);
                    if (jsonLd != null)
                    {
                        if (!string.IsNullOrWhiteSpace(jsonLd.Title)) metadata.Title = jsonLd.Title;
                        if (!string.IsNullOrWhiteSpace(jsonLd.Description)) metadata.Description = jsonLd.Description;
                        if (!string.IsNullOrWhiteSpace(jsonLd.ImageUrl)) metadata.ImageUrl = jsonLd.ImageUrl;
                        if (!string.IsNullOrWhiteSpace(jsonLd.PublishYear)) metadata.PublishYear = jsonLd.PublishYear;
                        if (!string.IsNullOrWhiteSpace(jsonLd.Language)) metadata.Language = jsonLd.Language;
                        if (!string.IsNullOrWhiteSpace(jsonLd.Publisher)) metadata.Publisher = jsonLd.Publisher;
                        if (jsonLd.Authors != null && jsonLd.Authors.Any()) metadata.Authors = jsonLd.Authors;
                    }

                    // If the page explicitly indicates the audiobook is unavailable, skip accepting this page
                    if (IsUnavailablePage(doc))
                    {
                        _logger.LogDebug("Audible page for {Url} appears unavailable; skipping", url);
                        continue;
                    }

                    // ASIN - set canonical property only
                    metadata.Asin = asin;

                    // Extract from adbl-product-details component FIRST (Audible's primary metadata container)
                    if (url.Contains("audible.com"))
                    {
                        ExtractFromProductDetails(doc, metadata);
                    }

                    // Title (fall back to visible selectors if component didn't provide)
                    if (string.IsNullOrWhiteSpace(metadata.Title))
                    {
                        var titleNode = doc.DocumentNode.SelectSingleNode("//h1 | //h1//span | //span[@id='productTitle'] | //meta[@property='og:title']");
                        var title = titleNode?.InnerText?.Trim() ?? titleNode?.GetAttributeValue("content", null)?.Trim();
                        if (!string.IsNullOrWhiteSpace(title)) metadata.Title = System.Text.RegularExpressions.Regex.Replace(title, "\\s+", " ").Trim();
                    }
                    
                    // Description - fallback to older selectors if not found in product-details
                    if (string.IsNullOrWhiteSpace(metadata.Description))
                    {
                        metadata.Description = ExtractDescription(doc);
                    }

                    // Language / PublishYear - fallback if not from product-details
                    if (string.IsNullOrWhiteSpace(metadata.Language))
                    {
                        metadata.Language = ExtractLanguage(doc);
                    }
                    if (string.IsNullOrWhiteSpace(metadata.PublishYear))
                    {
                        metadata.PublishYear = ExtractPublishYear(doc);
                    }
                    
                    // Clean language field - remove currency codes
                    if (!string.IsNullOrWhiteSpace(metadata.Language))
                    {
                        metadata.Language = CleanLanguage(metadata.Language);
                    }

                    // Image (only if not already extracted from component)
                    if (string.IsNullOrWhiteSpace(metadata.ImageUrl))
                    {
                        var img = doc.DocumentNode.SelectSingleNode("//meta[@property='og:image']")?.GetAttributeValue("content", null)
                            ?? doc.DocumentNode.SelectSingleNode("//img[contains(@class,'cover') or contains(@id,'main-image')]")?.GetAttributeValue("src", null);
                        if (!string.IsNullOrWhiteSpace(img)) metadata.ImageUrl = img;
                    }

                    // Authors (only if not already extracted from component)
                    if (metadata.Authors == null || !metadata.Authors.Any())
                    {
                        var authorNodes = doc.DocumentNode.SelectNodes("//a[contains(@href,'/author')]|//span[contains(@class,'author')]|//li[contains(.,'By')]");
                        if (authorNodes != null)
                        {
                            var authors = authorNodes
                                .Select(n => NormalizeNameString(n.InnerText))
                                .Where(s => !string.IsNullOrWhiteSpace(s) && !IsAuthorNoise(s))
                                .Distinct()
                                .Take(10)
                                .ToList();
                            if (authors.Any()) metadata.Authors = authors!;
                        }
                    }

                    // Narrators - target specific product page elements, avoid recommendation sections
                    if (metadata.Narrators == null || !metadata.Narrators.Any())
                    {
                        var narratorNodes = doc.DocumentNode.SelectNodes(
                            "//li[contains(@class,'narratorLabel')]//a | " +
                            "//span[contains(@class,'narratorLabel')]//a | " +
                            "//li[contains(.,'Narrated by:')]//a | " +
                            "//span[contains(.,'Narrated by:')]/following-sibling::a[position() <= 5]");
                        if (narratorNodes != null)
                        {
                            var narrators = narratorNodes
                                .Select(n => n.InnerText?.Trim())
                                .Where(s => !string.IsNullOrWhiteSpace(s) && !s.Contains("Narrated by"))
                                .Distinct()
                                .Take(10) // Limit to first 10 to avoid aggregate lists
                                .ToList();
                            if (narrators.Any()) metadata.Narrators = narrators!;
                        }
                    }

                    // Publisher - try meta tags or labeled fields (fallback if not from product-details)
                    if (string.IsNullOrWhiteSpace(metadata.Publisher))
                    {
                        var publisher = doc.DocumentNode.SelectSingleNode("//meta[@name='publisher']")?.GetAttributeValue("content", null)
                            ?? doc.DocumentNode.SelectSingleNode("//li[contains(.,'Publisher')]|//th[contains(.,'Publisher')]/following-sibling::td")?.InnerText?.Trim();
                        if (!string.IsNullOrWhiteSpace(publisher)) metadata.Publisher = publisher;
                    }

                    // Genres - best effort: look for breadcrumb or category (fallback if not from product-details)
                    if (metadata.Genres == null || !metadata.Genres.Any())
                    {
                        var genreNodes = doc.DocumentNode.SelectNodes("//a[contains(@href,'/genres') or contains(@class,'genre')]|//li[contains(@class,'genre')]//a");
                        if (genreNodes != null)
                        {
                            metadata.Genres = genreNodes.Select(n => n.InnerText?.Trim()).Where(s => !string.IsNullOrWhiteSpace(s)).Distinct().ToList()!;
                        }
                    }

                    // Runtime - try to extract minutes (fallback if not from product-details)
                    if (metadata.Runtime == null)
                    {
                        var runtimeText = doc.DocumentNode.SelectSingleNode("//span[contains(@class,'runtimeLabel')]|//li[contains(text(),'hrs')]|//span[contains(text(),'hr')]")?.InnerText;
                        if (!string.IsNullOrWhiteSpace(runtimeText))
                        {
                            var hrsMatch = System.Text.RegularExpressions.Regex.Match(runtimeText, "(\\d+)\\s*hrs?");
                            var minsMatch = System.Text.RegularExpressions.Regex.Match(runtimeText, "(\\d+)\\s*mins?");
                            int total = 0;
                            if (hrsMatch.Success) total += int.Parse(hrsMatch.Groups[1].Value) * 60;
                            if (minsMatch.Success) total += int.Parse(minsMatch.Groups[1].Value);
                            if (total > 0) metadata.Runtime = total;
                        }
                    }

                    // Ensure at least ASIN or Title present before accepting
                    if (!string.IsNullOrWhiteSpace(metadata.Title) || !string.IsNullOrWhiteSpace(metadata.ImageUrl) || (metadata.Authors != null && metadata.Authors.Any()))
                    {
                        _logger.LogInformation("Metadata extracted for ASIN {Asin}: Title={Title}, Authors={AuthorCount}, Language={Language}, Publisher={Publisher}, HasDescription={HasDesc}",
                            asin, metadata.Title, metadata.Authors?.Count ?? 0, metadata.Language, metadata.Publisher, !string.IsNullOrWhiteSpace(metadata.Description));
                        
                        if (_cache != null)
                        {
                            _cache.Set(cacheKey, metadata, TimeSpan.FromHours(12));
                        }
                        return metadata;
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogDebug(ex, "Scrape attempt failed for URL {Url}", url);
                }
            }

            // If nothing found, return minimal metadata with ASIN to allow fallback
            var fallbackMeta = new AudibleBookMetadata { Asin = asin };
            if (_cache != null) _cache.Set(cacheKey, fallbackMeta, TimeSpan.FromHours(1));
            return fallbackMeta;
        }

        private async Task<(string? html, int statusCode)> GetHtmlAsync(string url)
        {
            try
            {
                // Always use Playwright for Audible URLs since adbl-product-details requires JS rendering
                if (url.Contains("audible.com"))
                {
                    _logger.LogInformation("Using Playwright for Audible URL to render adbl-product-details component: {Url}", url);
                    return await GetHtmlWithPlaywrightAsync(url);
                }
                
                using var request = new HttpRequestMessage(HttpMethod.Get, url);
                request.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36");
                request.Headers.Add("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8");
                request.Headers.Add("Accept-Language", "en-US,en;q=0.9");
                request.Headers.Add("Accept-Encoding", "gzip, deflate, br");
                var response = await _httpClient.SendAsync(request);
                var statusCode = (int)response.StatusCode;
                
                if (statusCode == 404)
                {
                    _logger.LogDebug("404 Not Found for {Url}", url);
                    return (null, 404);
                }
                
                if (response.IsSuccessStatusCode)
                {
                    var html = await response.Content.ReadAsStringAsync();
                    // Basic bot detection check
                    if (html.Contains("To discuss automated access to Amazon data please contact") || html.Contains("Robot Check") || html.Contains("automated traffic"))
                    {
                        _logger.LogDebug("Bot-detection detected in HTTP fetch for {Url}", url);
                    }
                    else
                    {
                        return (html, statusCode);
                    }
                }

                // Try Playwright fallback on-demand (await-using for async disposables)
                return await GetHtmlWithPlaywrightAsync(url);
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "GetHtmlAsync failed for {Url}", url);
                return (null, 0);
            }
        }

        private async Task<(string? html, int statusCode)> GetHtmlWithPlaywrightAsync(string url)
        {
            try
            {
                var pwLogger = _loggerFactory.CreateLogger("PlaywrightFallback");
                pwLogger.LogDebug("Starting Playwright rendering for {Url}", url);
                System.Threading.Interlocked.Increment(ref _playwrightFallbackCount);
                pwLogger.LogInformation("Playwright invocation count: {Count}", Interlocked.Read(ref _playwrightFallbackCount));
                
                using var playwright = await Microsoft.Playwright.Playwright.CreateAsync();
                await using var browser = await playwright.Chromium.LaunchAsync(new BrowserTypeLaunchOptions { Headless = true, Args = new[] { "--no-sandbox" } });
                await using var context = await browser.NewContextAsync(new BrowserNewContextOptions { IgnoreHTTPSErrors = true, UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36" });
                var page = await context.NewPageAsync();

                // Navigate and wait for network idle
                var gotoOptions = new Microsoft.Playwright.PageGotoOptions { WaitUntil = Microsoft.Playwright.WaitUntilState.NetworkIdle, Timeout = 30000 };
                var pwResponse = await page.GotoAsync(url, gotoOptions);
                
                var responseStatus = pwResponse?.Status ?? 0;
                if (responseStatus == 404)
                {
                    pwLogger.LogDebug("Playwright received 404 for {Url}", url);
                    return (null, 404);
                }

                // Wait for Audible-specific component or common title selectors
                var selectors = new[] { "adbl-product-details", "adbl-page[loaded]", "#productTitle", ".productTitle", ".product-title", "meta[property=\"og:title\"]" };
                bool found = false;
                foreach (var sel in selectors)
                {
                    try
                    {
                        var wait = await page.WaitForSelectorAsync(sel, new PageWaitForSelectorOptions { Timeout = 5000 });
                        if (wait != null)
                        {
                            pwLogger.LogInformation("Playwright selector matched {Selector} for {Url}", sel, url);
                            found = true;
                            break;
                        }
                    }
                    catch (TimeoutException)
                    {
                        // ignore timeouts per selector
                    }
                }

                // Give extra time for adbl-product-details to fully render
                if (found)
                {
                    await page.WaitForTimeoutAsync(2000); // Wait 2s for component hydration
                }

                var content = await page.ContentAsync();
                if (!string.IsNullOrWhiteSpace(content))
                {
                    pwLogger.LogInformation("Playwright rendered {Length} chars for {Url} (selectorMatched={Matched})", content.Length, url, found);
                    return (content, responseStatus > 0 ? responseStatus : 200);
                }
                
                return (null, 0);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Playwright rendering failed for {Url}", url);
                return (null, 0);
            }
        }

        public async Task<List<AudibleBookMetadata>> PrefetchAsync(List<string> asins)
        {
            var results = new List<AudibleBookMetadata>();
            foreach (var asin in asins)
            {
                var metadata = await ScrapeAudibleMetadataAsync(asin);
                results.Add(metadata);
            }
            return results;
        }

        private string? ExtractLanguage(HtmlDocument doc)
        {
            var languageNode = doc.DocumentNode.SelectSingleNode(
                "//div[@id='detailBullets_feature_div']//span[text()='Language']//following-sibling::span | " +
                "//div[@id='detailBullets_feature_div']//li[contains(.,'Language')]//span[position()>1] | " +
                "//li[contains(.,'Language')]//span[last()] | " +
                "//span[text()='Language:']/following-sibling::span | " +
                "//th[contains(text(),'Language')]/following-sibling::td | " +
                "//td[contains(text(),'Language:')]/following-sibling::td | " +
                "//tr[@id='detailsLanguage']//td//span");
            var text = languageNode?.InnerText.Trim();
            if (text == "Language" || string.IsNullOrEmpty(text))
            {
                var languageListItem = doc.DocumentNode.SelectSingleNode("//li[contains(.,'Language')]");
                if (languageListItem != null)
                {
                    var listText = languageListItem.InnerText.Trim();
                    var match = System.Text.RegularExpressions.Regex.Match(listText, @"Language[:\s]+([^;\(\n]+)", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                    if (match.Success)
                    {
                        text = match.Groups[1].Value.Trim();
                    }
                }
            }
            if (!string.IsNullOrEmpty(text) && text != "Language")
            {
                text = text.Replace("Language:", "").Trim();
                return text;
            }
            return null;
        }

        private string? ExtractDescription(HtmlDocument doc)
        {
            var descriptionNode = doc.DocumentNode.SelectSingleNode(
                "//div[@data-expanded and contains(@class,'a-expander-content')] | " +
                "//div[@id='bookDescription_feature_div']//div[contains(@class,'a-expander-content')] | " +
                "//div[@id='bookDescription_feature_div']//noscript | " +
                "//div[@id='bookDescription_feature_div']//span | " +
                "//div[@id='productDescription']//p | " +
                "//div[@id='productDescription'] | " +
                "//div[contains(@class,'bookDescription')]//span | " +
                "//div[contains(@class,'productDescription')] | " +
                "//span[@id='productDescription'] | " +
                "//div[@data-feature-name='bookDescription']//span");
            if (descriptionNode != null)
            {
                var htmlContent = descriptionNode.InnerHtml?.Trim();
                if (!string.IsNullOrEmpty(htmlContent))
                {
                    htmlContent = System.Text.RegularExpressions.Regex.Replace(htmlContent, @"\s+", " ");
                    htmlContent = System.Text.RegularExpressions.Regex.Replace(htmlContent, @">\s+<", "><");
                    return htmlContent.Trim();
                }
            }
            return null;
        }

        private string? ExtractPublishYear(HtmlDocument doc)
        {
            var releaseDateNode = doc.DocumentNode.SelectSingleNode(
                "//div[@id='detailBullets_feature_div']//span[contains(text(),'Audible.com release date') or contains(text(),'Release date')]/following-sibling::span | " +
                "//li[contains(.,'Audible.com release date') or contains(.,'Release date')]//span[last()] | " +
                "//span[contains(text(),'release date')]/following-sibling::span | " +
                "//th[contains(text(),'Release')]/following-sibling::td | " +
                "//td[contains(text(),'Release')]/following-sibling::td");
            var dateText = releaseDateNode?.InnerText.Trim();
            if (string.IsNullOrEmpty(dateText) || dateText.ToLower().Contains("release"))
            {
                var releaseDateListItem = doc.DocumentNode.SelectSingleNode("//li[contains(.,'release date')]");
                if (releaseDateListItem != null)
                {
                    var listText = releaseDateListItem.InnerText.Trim();
                    var match = System.Text.RegularExpressions.Regex.Match(listText, @"release date[:\s]+([^;\(\n]+)", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                    if (match.Success)
                    {
                        dateText = match.Groups[1].Value.Trim();
                    }
                }
            }
            return ExtractYear(dateText);
        }

        /// <summary>
        /// Normalize a raw name string from scraped HTML: remove labels, split on common separators,
        /// trim and dedupe names, and return a comma-joined string (or null if empty).
        /// </summary>
        private string? NormalizeNameString(string? raw)
        {
            if (string.IsNullOrWhiteSpace(raw)) return null;
            // Remove common labels
            raw = System.Text.RegularExpressions.Regex.Replace(raw, "Narrated by:|Narrated by|Narrator:|By:", "", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            raw = raw.Replace("\n", ", ").Replace("\\r", ", ").Replace("\t", " ");
            // Split on commas, 'and', '/', '&' and other separators
            var parts = System.Text.RegularExpressions.Regex.Split(raw, @",|\band\b|/|&|\\u0026");
            var names = parts.Select(p => p?.Trim()).Where(s => !string.IsNullOrWhiteSpace(s)).Distinct().ToList();
            if (!names.Any()) return null;
            return string.Join(", ", names);
        }

        private record JsonLdData(string? Title, string? Description, string? ImageUrl, string? PublishYear, string? Language, string? Publisher, List<string>? Authors);

        private JsonLdData? ExtractFromJsonLd(HtmlDocument doc)
        {
            try
            {
                var scriptNodes = doc.DocumentNode.SelectNodes("//script[@type='application/ld+json']");
                if (scriptNodes == null) return null;
                foreach (var sn in scriptNodes)
                {
                    var text = sn.InnerText?.Trim();
                    if (string.IsNullOrWhiteSpace(text)) continue;
                    try
                    {
                        using var docJson = JsonDocument.Parse(text);
                        var root = docJson.RootElement;
                        // Handle either an object or an array
                        if (root.ValueKind == JsonValueKind.Array && root.GetArrayLength() > 0)
                        {
                            root = root[0];
                        }
                        string? title = null, desc = null, img = null, year = null, lang = null, pub = null;
                        List<string>? authors = null;
                        if (root.TryGetProperty("name", out var p)) title = p.GetString();
                        if (root.TryGetProperty("headline", out p)) desc = p.GetString();
                        if (root.TryGetProperty("description", out p) && string.IsNullOrEmpty(desc)) desc = p.GetString();
                        if (root.TryGetProperty("image", out p)) img = p.ValueKind == JsonValueKind.String ? p.GetString() : p[0].GetString();
                        if (root.TryGetProperty("datePublished", out p)) year = p.GetString();
                        if (root.TryGetProperty("inLanguage", out p)) lang = p.GetString();
                        if (root.TryGetProperty("publisher", out p) && p.ValueKind == JsonValueKind.Object && p.TryGetProperty("name", out var np)) pub = np.GetString();
                        if (root.TryGetProperty("author", out p))
                        {
                            authors = new List<string>();
                            if (p.ValueKind == JsonValueKind.Array)
                            {
                                foreach (var a in p.EnumerateArray())
                                {
                                    if (a.ValueKind == JsonValueKind.Object && a.TryGetProperty("name", out var an)) authors.Add(an.GetString() ?? "");
                                    else if (a.ValueKind == JsonValueKind.String) authors.Add(a.GetString() ?? "");
                                }
                            }
                            else if (p.ValueKind == JsonValueKind.Object && p.TryGetProperty("name", out var an)) authors.Add(an.GetString() ?? "");
                            else if (p.ValueKind == JsonValueKind.String) authors.Add(p.GetString() ?? "");
                        }
                        return new JsonLdData(title, desc, img, year, lang, pub, authors);
                    }
                    catch (JsonException) { continue; }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "Error parsing JSON-LD");
            }
            return null;
        }

        private bool IsUnavailablePage(HtmlDocument doc)
        {
            var title = doc.DocumentNode.SelectSingleNode("//title")?.InnerText ?? string.Empty;
            if (!string.IsNullOrEmpty(title) && title.ToLower().Contains("not available")) return true;
            var bodyText = doc.DocumentNode.InnerText ?? string.Empty;
            if (bodyText.IndexOf("this audiobook is not available", StringComparison.OrdinalIgnoreCase) >= 0) return true;
            if (bodyText.IndexOf("audiobook is not available", StringComparison.OrdinalIgnoreCase) >= 0) return true;
            return false;
        }

        private string? ExtractYear(string? dateText)
        {
            if (string.IsNullOrEmpty(dateText)) return null;
            var yearMatch = System.Text.RegularExpressions.Regex.Match(dateText, @"\b(19|20)\d{2}\b");
            return yearMatch.Success ? yearMatch.Value : null;
        }

        /// <summary>
        /// Extract metadata from adbl-product-details component (Audible's primary metadata container).
        /// This component contains: title, image, summary, authors, narrators, series, release date, language, format, length, publisher, categories, tags.
        /// </summary>
        private void ExtractFromProductDetails(HtmlDocument doc, AudibleBookMetadata metadata)
        {
            var productDetails = doc.DocumentNode.SelectSingleNode("//adbl-product-details");
            if (productDetails == null)
            {
                _logger.LogInformation("adbl-product-details component not found in HTML for ASIN {Asin}", metadata.Asin);
                return;
            }
            
            // Log component structure to understand content
            var innerHtmlLength = productDetails.InnerHtml?.Length ?? 0;
            _logger.LogInformation("adbl-product-details found for ASIN {Asin}, inner HTML: {Length} chars", metadata.Asin, innerHtmlLength);

            // Title - look for h1 within the component (OVERRIDE any previous extraction to avoid "Audible" site logo)
            var titleNode = productDetails.SelectSingleNode(".//h1[@class='bc-heading']")
                         ?? productDetails.SelectSingleNode(".//h1")
                         ?? doc.DocumentNode.SelectSingleNode("//h1[contains(@class,'bc-heading')]");
            if (titleNode != null)
            {
                var title = titleNode.InnerText?.Trim();
                if (!string.IsNullOrWhiteSpace(title) && title != "Audible")
                {
                    metadata.Title = System.Text.RegularExpressions.Regex.Replace(title, @"\s+", " ").Trim();
                    _logger.LogInformation("Extracted title from component: {Title}", metadata.Title);
                }
            }

            // Image - look for product image (book cover), not site logo
            // Try meta og:image first (most reliable), then look for product-specific images
            var imgNode = doc.DocumentNode.SelectSingleNode("//meta[@property='og:image']")
                       ?? productDetails.SelectSingleNode(".//img[contains(@src,'images/I/')]")
                       ?? doc.DocumentNode.SelectSingleNode("//img[contains(@src,'images/I/') and contains(@src,'_SL')]")
                       ?? productDetails.SelectSingleNode(".//img[contains(@class,'bc-image-inset-border')]")
                       ?? productDetails.SelectSingleNode(".//img");
            if (imgNode != null)
            {
                var imgUrl = imgNode.GetAttributeValue("content", null) ?? imgNode.GetAttributeValue("src", null);
                // Filter out logos and navigation images
                if (!string.IsNullOrWhiteSpace(imgUrl) && !imgUrl.Contains("/navigation/") && !imgUrl.Contains("logo"))
                {
                    // Clean up social share overlay URLs - extract the base image ID
                    // Example: https://m.media-amazon.com/images/I/61D7uTS7-TL._SL10_UR1600,800_CR200,50,1200,630_CLa|1200,630|61D7uTS7-TL.jpg|...
                    // Should become: https://m.media-amazon.com/images/I/61D7uTS7-TL._SL500_.jpg
                    var cleanUrl = imgUrl;
                    if (imgUrl.Contains("PJAdblSocialShare") || imgUrl.Contains("_CLa"))
                    {
                        // Extract image ID (e.g., 61D7uTS7-TL)
                        var match = System.Text.RegularExpressions.Regex.Match(imgUrl, @"/images/I/([A-Za-z0-9_-]+)\.");
                        if (match.Success)
                        {
                            var imageId = match.Groups[1].Value;
                            cleanUrl = $"https://m.media-amazon.com/images/I/{imageId}._SL500_.jpg";
                            _logger.LogInformation("Cleaned social share URL to: {CleanUrl}", cleanUrl);
                        }
                    }
                    metadata.ImageUrl = cleanUrl;
                    _logger.LogInformation("Extracted image URL from component: {Url}", cleanUrl);
                }
                else
                {
                    _logger.LogWarning("Found image but filtered as logo/nav: {Url}", imgUrl);
                }
            }
            else
            {
                _logger.LogWarning("No image element found in component or page");
            }

            // Authors - Extract from FULL PAGE after Playwright rendering, targeting product details area
            // Look for links to /author/ pages - the FIRST one is always the book's actual author
            var pageAuthorNodes = doc.DocumentNode.SelectNodes("//a[contains(@href,'/author/')]");
            if (pageAuthorNodes != null)
            {
                var authors = pageAuthorNodes
                    .Select(n => NormalizeNameString(n.InnerText))
                    .Where(s => !string.IsNullOrWhiteSpace(s) && !IsAuthorNoise(s))
                    .Distinct()
                    .Take(1) // Take only the first author - it's always the book's author, rest are recommendations
                    .ToList();
                if (authors.Any())
                {
                    metadata.Authors = authors!;
                    _logger.LogInformation("Extracted {Count} author(s) from Playwright-rendered page: {Authors}", authors.Count, string.Join(", ", authors));
                }
                else
                {
                    _logger.LogWarning("Found {Count} author links but all filtered out as noise", pageAuthorNodes.Count);
                }
            }
            else
            {
                _logger.LogWarning("No author links (href='/author/') found in Playwright-rendered page");
            }

            // Summary (description) - look for adbl-text-block with slot="summary"
            // Extract this BEFORE narrators so we can parse narrator from description if needed
            // The rendered Audible page uses custom web components
            var summaryNode = productDetails.SelectSingleNode(".//adbl-text-block[@slot='summary']") 
                           ?? productDetails.SelectSingleNode(".//div[@slot='summary']")
                           ?? productDetails.SelectSingleNode(".//span[@class='bc-text bc-publisher-summary-text']") 
                           ?? doc.DocumentNode.SelectSingleNode("//adbl-text-block[@slot='summary']");
            
            _logger.LogInformation("Summary node search result: {Found}", summaryNode != null ? "Found" : "Not found");
            
            if (summaryNode != null && string.IsNullOrWhiteSpace(metadata.Description))
            {
                var summary = summaryNode.InnerText?.Trim();
                _logger.LogInformation("Summary text length: {Length}, starts with: {Start}", 
                    summary?.Length ?? 0, summary?.Substring(0, Math.Min(100, summary?.Length ?? 0)));
                    
                // Filter out UI elements like "Close", "Show more", etc.
                if (!string.IsNullOrWhiteSpace(summary) && summary.Length > 50 && 
                    !summary.Equals("Close", StringComparison.OrdinalIgnoreCase) &&
                    !summary.Equals("Show more", StringComparison.OrdinalIgnoreCase))
                {
                    metadata.Description = System.Text.RegularExpressions.Regex.Replace(summary, @"\s+", " ").Trim();
                    _logger.LogInformation("Extracted description from adbl-product-details: {Length} chars", metadata.Description.Length);
                    
                    // Extract publisher from description - look for (P)YYYY Publisher pattern
                    if (string.IsNullOrWhiteSpace(metadata.Publisher))
                    {
                        var publisherMatch = System.Text.RegularExpressions.Regex.Match(metadata.Description, @"\(P\)\d{4}\s+([^\u00a9\n]+)");
                        if (publisherMatch.Success)
                        {
                            metadata.Publisher = publisherMatch.Groups[1].Value.Trim();
                            _logger.LogInformation("Extracted publisher from description: {Publisher}", metadata.Publisher);
                        }
                    }
                }
                else
                {
                    _logger.LogWarning("Summary node found but text filtered out: '{Text}'", summary?.Substring(0, Math.Min(50, summary?.Length ?? 0)));
                }
            }

            // Series information
            var seriesNode = productDetails.SelectSingleNode(".//li[contains(@class,'seriesLabel')] | .//span[contains(text(),'Series')]");
            if (seriesNode != null)
            {
                var seriesText = seriesNode.InnerText?.Trim();
                if (!string.IsNullOrWhiteSpace(seriesText))
                {
                    // Extract series name and number (e.g., "Empyrean, Book 1")
                    var match = System.Text.RegularExpressions.Regex.Match(seriesText, @"(?:Series:?\s*)?(.*?)(?:,\s*Book\s+(\d+))?", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                    if (match.Success)
                    {
                        var seriesName = match.Groups[1].Value.Trim();
                        if (!string.IsNullOrWhiteSpace(seriesName) && seriesName != "Series")
                        {
                            metadata.Series = seriesName;
                        }
                        if (match.Groups.Count > 2 && !string.IsNullOrWhiteSpace(match.Groups[2].Value))
                        {
                            metadata.SeriesNumber = match.Groups[2].Value;
                        }
                    }
                }
            }

            // Extract all detail rows (Release date, Language, Format, Length, Publisher, etc.)
            var detailRows = productDetails.SelectNodes(".//li[contains(@class,'bc-list-item')] | .//div[contains(@class,'bc-row')]");
            if (detailRows != null)
            {
                foreach (var row in detailRows)
                {
                    var rowText = row.InnerText?.Trim();
                    if (string.IsNullOrWhiteSpace(rowText)) continue;

                    // Release date
                    if (rowText.Contains("Release date:", StringComparison.OrdinalIgnoreCase) && string.IsNullOrWhiteSpace(metadata.PublishYear))
                    {
                        var dateMatch = System.Text.RegularExpressions.Regex.Match(rowText, @"Release date:\s*([^\n]+)", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                        if (dateMatch.Success)
                        {
                            metadata.PublishYear = ExtractYear(dateMatch.Groups[1].Value);
                        }
                    }

                    // Language
                    if (rowText.Contains("Language:", StringComparison.OrdinalIgnoreCase) && string.IsNullOrWhiteSpace(metadata.Language))
                    {
                        var langMatch = System.Text.RegularExpressions.Regex.Match(rowText, @"Language:\s*([^\n]+)", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                        if (langMatch.Success)
                        {
                            metadata.Language = langMatch.Groups[1].Value.Trim();
                        }
                    }

                    // Format/Version
                    if (rowText.Contains("Version:", StringComparison.OrdinalIgnoreCase) || rowText.Contains("Format:", StringComparison.OrdinalIgnoreCase))
                    {
                        if (rowText.Contains("Unabridged", StringComparison.OrdinalIgnoreCase))
                        {
                            metadata.Version = "Unabridged";
                            metadata.Abridged = false;
                        }
                        else if (rowText.Contains("Abridged", StringComparison.OrdinalIgnoreCase))
                        {
                            metadata.Version = "Abridged";
                            metadata.Abridged = true;
                        }
                    }

                    // Length (runtime)
                    if (rowText.Contains("Length:", StringComparison.OrdinalIgnoreCase) && metadata.Runtime == null)
                    {
                        var hrsMatch = System.Text.RegularExpressions.Regex.Match(rowText, @"(\d+)\s*hrs?", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                        var minsMatch = System.Text.RegularExpressions.Regex.Match(rowText, @"(\d+)\s*mins?", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                        int total = 0;
                        if (hrsMatch.Success) total += int.Parse(hrsMatch.Groups[1].Value) * 60;
                        if (minsMatch.Success) total += int.Parse(minsMatch.Groups[1].Value);
                        if (total > 0) metadata.Runtime = total;
                    }

                    // Publisher
                    if (rowText.Contains("Publisher:", StringComparison.OrdinalIgnoreCase) && string.IsNullOrWhiteSpace(metadata.Publisher))
                    {
                        var pubMatch = System.Text.RegularExpressions.Regex.Match(rowText, @"Publisher:\s*([^\n]+)", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                        if (pubMatch.Success)
                        {
                            metadata.Publisher = pubMatch.Groups[1].Value.Trim();
                        }
                    }
                }
            }

            // Categories (genres) and Tags from chips
            var categoryNodes = productDetails.SelectNodes(".//span[contains(@class,'bc-chip-text')] | .//a[contains(@class,'bc-chip')]");
            if (categoryNodes != null)
            {
                var categories = categoryNodes
                    .Select(n => n.InnerText?.Trim())
                    .Where(s => !string.IsNullOrWhiteSpace(s))
                    .Distinct()
                    .ToList();
                if (categories.Any())
                {
                    if (metadata.Genres == null || !metadata.Genres.Any())
                    {
                        metadata.Genres = categories!;
                    }
                    if (metadata.Tags == null || !metadata.Tags.Any())
                    {
                        metadata.Tags = categories!;
                    }
                }
            }
        }

        /// <summary>
        /// Clean language field by removing currency codes and normalizing.
        /// </summary>
        private string CleanLanguage(string language)
        {
            if (string.IsNullOrWhiteSpace(language)) return language;
            
            // Remove currency codes (e.g., "English - USD" -> "English")
            var cleaned = System.Text.RegularExpressions.Regex.Replace(language, @"\s*-\s*(USD|EUR|GBP|CAD|AUD|INR)\s*$", "", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            
            // Remove other common noise
            cleaned = cleaned.Replace("Language:", "").Trim();
            
            return cleaned;
        }

        /// <summary>
        /// Check if author string is navigation noise or invalid.
        /// </summary>
        private bool IsAuthorNoise(string? author)
        {
            if (string.IsNullOrWhiteSpace(author)) return true;
            var a = author.Trim();
            if (a.Length < 2) return true;
            
            // Filter out common Amazon/Audible navigation elements
            var noisePhrases = new[] { 
                "Shop By", "Shop by", "Authors", "By:", "Sort by", 
                "Written by", "See all", "Browse", "More by",
                "Visit Amazon", "Visit", "Learn more"
            };
            
            foreach (var noise in noisePhrases)
            {
                if (a.Contains(noise, StringComparison.OrdinalIgnoreCase)) return true;
            }
            
            return false;
        }
    }

    public interface IAudibleMetadataService
    {
        Task<AudibleBookMetadata> ScrapeAudibleMetadataAsync(string asin);
        Task<List<AudibleBookMetadata>> PrefetchAsync(List<string> asins);
    }
}